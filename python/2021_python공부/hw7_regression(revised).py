# -*- coding: utf-8 -*-
"""hw7_regression(revised).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11D6UhjGZ9ofOuky1ZUZFn6Df0G5Kzxd1

## 과제1_MY ANSWER
"""

import numpy as np
from sklearn.metrics import mean_squared_error as mse
import matplotlib.pyplot as plt
w_list = np.arange(1.0, 0, -0.1) # 0.1씩 감소하는 w_list 값 생성
# 5개의 점 x, y 좌표값
x = np.array([1, 4.5, 9, 10, 13])
y = np.array([0, 0.2, 2.5, 5.4, 7.3])

# 그래프_subplot활용
plt.subplot(1,2,1)
for w in list(w_list):
  x = np.array([1, 4.5, 9, 10, 13])
  y = np.array([0, 0.2, 2.5, 5.4, 7.3]) 
  y_hat = w * x
  mse_y = mse(y_hat, y)
  print('w = {:.1f}, 평균제곱 오차: {:.2f}'.format(w, mse_y))
  plt.title("MSE optimization graph")
  plt.xlabel("w")
  plt.ylabel("mse")
  plt.axis([0,1.05, 0, 24.0]) 
  plt.plot(w, mse_y, 'bo') #그래프가 scatter로만 그려지고, 선으로 그려지지 않음.

plt.subplot(1,2,2)
def make_linear(w = 0.5, size = 50):
  x = np.array([1, 4.5, 9, 10, 13])
  y = w * x 
  # m, b = np.polyfit(x, y, 1) # y의 데이터에 대한 최적의 피팅(최소제곱 관점에서)인 1차 다항식 m(x), b(x)의 계수 반환
  # print(m,b)
  plt.plot(x, y ,'b') # 파란 직선 
  plt.title("5 data and regression line")
  plt.xlabel('x')
  plt.ylabel('y')
  plt.axis([0,13.5,-0.5,7.7]) # X, Y축의 범위: [xmin, xmax, ymin, ymax]
  plt.plot([1, 4.5, 9, 10, 13],[0, 0.2, 2.5, 5.4, 7.3], 'ro') # 빨간(관측 데이터) 점
  return x, y
make_linear()

"""# 과제 1_ answer"""

import numpy as np
from sklearn.metrics import mean_squared_error as mse
import matplotlib.pyplot as plt
import pandas as pd

# 5개의 점 x, y 좌표값
x = np.array([1, 4.5, 9, 10, 13])
y = np.array([0, 0.2, 2.5, 5.4, 7.3])

def h(x,w):
  return w*x

w_list = np.arange(1.0, 0, -0.1)
mse_list = np.array([])
min = mse(h(x, w_list[0]),y)

for w in list(w_list):
  print('w = {:.1f}, 평균제곱 오차: {:.2f}'.format(w,mse(h(x,w),y)))
  mse_list = np.append(mse_list, mse(h(x,w), y))
  if min > mse(h(x,w),y):
    min = mse(h(x,w),y)
    min_w = w


plt.figure(figsize=(10,5))
plt.subplot(1,2,1)
plt.title("MSE optimization graph")
plt.plot(w_list, mse_list, "b-")


plt.subplot(1,2,2)
plt.title('5 data and regression line')
plt.plot(x,y,'ro')
plt.plot(x, h(x,min_w), '-', label='y={:.1f}*x'.format(min_w))
plt.legend()

"""# 과제2_MY ANSWER"""

# 슬라이드 내용 _하다 맘.
import numpy as np
import matplotlib.pyplot as plt

def make_linear(w=0.5, b = 0.8, size=80, noise=1.0):
  x = np.random.rand(size)
  y = w * x + b
  noise = np.random.uniform(-abs(noise), abs(noise), size=y.shape)
  yy = y + noise
  plt.figure(figsize = (10, 7))
  plt.plot(x, y, color='r', label=f'y = {w}*x + {b}')
  plt.scatter(x, yy, label = 'data')
  plt.legend(fontsize=20)
  plt.show()
  print(f'w: {w}, b: {b}')
  return x, yy

x, y = make_linear(w=0.3, b=0.5, size=100, noise=0.01)
# 임의의 2개의 outliner 추가
y[5] = 0.75
y[10] = 0.75

plt.figure(figsize=(10, 7))
plt.scatter(x, y)
plt.show()

# read file
import urllib.request
import numpy as np
import pandas as pd
data_home = 'http://github.com/dknife/ML/raw/main/data/pollution.csv'
lin_data = pd.read_csv(data_home)
i_data = lin_data["input"]
p_data = lin_data["pollution"]
lin_data

x = i_data
y = p_data

w_list = np.arange(50.0, 0, -0.1)
print(w_list) # input(w) = 11일 때 pollutino 최솟값
for w in list(w_list):
  x = i_data
  y = p_data 
  y_hat = w * x
  mse_y = mse(y_hat, y)
  print('w = {:.1f}, 평균제곱 오차: {:.2f}'.format(w, mse_y))

import numpy as np
import matplotlib.pyplot as plt

def make_linear(w=0.5, b = 0.8, size=80, noise=1.0):
  x = p_data
  y = w * x + b
  noise = np.random.uniform(-abs(noise), abs(noise), size=y.shape)
  yy = y + noise
  plt.figure(figsize = (10, 7))
  plt.plot(x, y, color='r', label=f'y = {w}*x + {b}')
  plt.scatter(x, yy, label = 'data')
  plt.legend(fontsize=20)
  print(f'w: {w}, b: {b}')
  return x, yy

plt.subplot(1,2,1)
# make_linear(w=11, b=0.5, size=100, noise=0.01)
# plt.figure(figsize=(10, 7))
# plt.scatter(x, y)
# plt.show()
x, y = make_linear(w=11, b=0.5, size=100, noise=0.01)
iteration = 5000
# 학습율
learning_rate = 0.05
errors = []

# w,b 초기화
w = np.random.uniform(low = -3.0, high= 1.0)
b = np.random.uniform(low = -3.0, high= 1.0)
for i in range(iteration):
  y_model = x * w + b
  error = ((y_model - y)**2).mean()
  if error < 0.0005:
    break
  w = w - learning_rate * ((y_model - y)* x).mean()
  b = b - learning_rate * (y_model - y).mean()
  errors.append(error)

  # if i % 5 == 0:
  #   print("{0:2} w = {1:.5f}, b = {2:.5f} error = {3:.5f}".format(i, w, b, error))

# print("----" * 15)
# print("{0:2} w = {1:.1f}, b = {2:.1f} error = {3:.5f}".format(i, w, b, error))

plt.subplot(1,2,2)
plt.figure(figsize=(10,7))
plt.plot(errors)
plt.xlabel('Epochs')
plt.ylabel('Error')

"""# 과제2_ANSWER"""

# read file
import urllib.request
import numpy as np
import pandas as pd
data_home = 'http://github.com/dknife/ML/raw/main/data/pollution.csv'
lin_data = pd.read_csv(data_home)
x = lin_data["input"]
y = lin_data["pollution"]
lin_data

# w,b 초기화
w = np.random.uniform(low = -1.0, high= 1.0)
b = np.random.uniform(low = -1.0, high= 1.0)

y_model = w * x + b
error = (y_model -y)**2
iteration = 5000
learning_rate = 0.05
errors = []

for i in range(iteration):
  y_model = w * x + b
  error = ((y_model - y)**2).mean()
  if error < 0.0005:
    break
  w = w - learning_rate * ((y_model - y)*x).mean()
  b = b - learning_rate * (y_model - y).mean()
  errors.append(error)

print("{0:2} w = {2:.5f},b = {2:.5f} error = {3:.5f}".format(i,w,b,error))

plt.figure(figsize=(15,5))
plt.subplot(1,2,1)
plt.plot(x,y, ',', label = 'lin_data')
plt.plot([0, x.max()], [(0*w+b), (x.max()*w+b)], 'r', label = 'y={:.1f}*x+{:.1f}'.format(w,b))
plt.legend()

plt.subplot(1,2,2)
plt.plot(errors)
plt.xlabel("Epochs")
# plt.ylabel("Error")


## 객체와 변수
### 1. 인캡슐레이션(캡슐화) <br>
+ 비슷한 것끼리 모아놓는 것. 
+ 클래스, 모듈 통틀어서
객체 == 부품 <br>
좋은 객체 = 좋은 부품 = `외부로부터 영향을 덜 받게 하는 것(=케이스덮는 것)` <br>
조건문/반복문(부품)을 감싸는 함수(케이스) <br>
작은 부품을 묶어서 객체를 만듦. <br>
+ 객체 지향 프로그래밍에서 핵심 = Encaptulation <br>
+ 객체 안에 들어있는 여러 가지(특히 데이터)가 외부로부터 영향을 받지 않도록 하는 여러 프로그래밍적 기법 -> 캡슐화의 특성을 위해서 만들어 진 것. <br>
+ data vs logic(조건문, 반복문) which is more important? <br>
: `data` ! #데이터, 변수는 매우 중요하다.` <br>
+ 데이터와 변수는 중요하다.

### 2. instance 변수의 특성
+ instance마다 값이 달라지는 변수 = instance 변수
```
class C(object):
    def __init__(self,v): #첫 번째 매개변수(self)반드시 지정!
        self.value = v
    def show(self):
        print(self.vlaue)
c1 = C(10) #c값이 v로 들어감.
#self와 c1은 같은 instance를 가리킴.
#instance(self)의 vlue값이 10이 됨.

#method바깥에서 instance 변수에 접근하는 것이 허용.-> 아래 3개 코드 처럼!
print(c1.value) #10
c1.value = 20
print(c1.value) #20

c1.show
```

### 3. set / get method
```
#set, get method
class C(object):
    def __init__(self, v):
        self.value = v
    def show(self):
        print(self.value)
    def getValue(self):
        return self.value
    def setValue(self, v):
        self.value = v


c1 = C(10)
print(c1.getValue())
c1.setValue(20)
print(c1.getValue())

#instacne를 직접 수정하지 않고 method를 통해 가져오고, 수정함.
```

### 4. set / get method를 사용하는 이유
```
class Cal(object): # class이름 뒤에 괄호 object를 적는다!
    def __init__(self, v1, v2):
        self.v1 = v1
        self.v2 = v2

    def add(self):
        return self.v1+self.v2

    def subtract(self):
        return self.v1-self.v2

c1 = Cal(10,10)
print(c1.add())
print(c1.subtract())

c1.v1 = 20 #변수의 값을 직접 변경
c1.v2 = 30
print(c1.add())
print(c1.subtract())
 #4분 26초~
 ```
### 5. 속성

